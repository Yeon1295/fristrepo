# Logging and intercepting database operations

- Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be 
  intercepted by application code. 
- This is most commonly used for logging SQL, but can also be used to modify or abort the command.

### Context Log property

```
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```

### Logging to different places

```
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}

var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```

### Changing log content and formatting

- Under the covers the Database.Log property makes use of a DatabaseLogFormatter object. 
- This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings 
  and a DbContext. 
 
 - This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF. 
   These DatabaseLogFormatter methods gather and format log output and send it to the delegate.
   
 ##### Customizing DatabaseLogFormatter
 
 - Changing what is logged and how it is formatted can be achieved by creating a new class that derives from 
   DatabaseLogFormatter and overrides methods as appropriate. 
   
- The most common methods to override are:

    - LogCommand – Override this to change how commands are logged before they are executed. 
      By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override 
      or handle parameters differently instead.
   -  LogResult – Override this to change how the outcome from executing a command is logged.
    - LogParameter – Override this to change the formatting and content of parameter logging.
    
    - For example, suppose we wanted to log just a single line before each command is sent to the database.
    - Note that this code does simplistic removal of line breaks just as an example. It will likely not work well 
      for viewing complex SQL.
      
```
    public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```
##### Setting the DatabaseLogFormatter

- Once a new DatabaseLogFormatter class has been created it needs to be registered with EF. 

```
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```

### Interception building blocks

- Using DbContext.Database.Log to log the SQL generated by EF  is actually a relatively thin façade over some 
  low-level building blocks for more general interception.
  
##### Interception interfaces

- The interception code is built around the concept of interception interfaces. 
- These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action. 
- The intent is to have one interface per type of object being intercepted.

- For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to 
  ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods. 
-Likewise, the interface defines methods that are called when each of these operations completes.

##### The interception context

- Every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext<>. 
  This object contains contextual information about the action that EF is taking.
  
- For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext. 
  Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.
  
##### Result handling

- The DbCommandInterceptionContext<> class contains a properties called Result, OriginalResult, Exception, and OriginalException.
- These properties are set to null/zero for calls to the interception methods that are called before the operation is executed
- If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.
- if the operation throws, then the Exception and OriginalException properties will be set.
- These values can then be observed in the interception methods that are called after the operation has executed.

##### Suppressing execution

- If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not 
  attempt to actually execute the command, but will instead just use the result set. 
- In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.

- An example of how this might be used is the command batching that has traditionally been done with a wrapping provider. 
  The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had 
  executed as normal.
  
- Execution can also be suppressed by setting the Exception property in one of the …Executing methods. This causes EF to 
  continue as if execution of the operation had failed by throwing the given exception.
  
- This may, of course, cause the application to crash, but it may also be a transient exception or some other exception 
  that is handled by EF. For example, this could be used in test environments to test the behavior of an application 
  when command execution fails.
  
  ##### Changing the result after execution
  
 - If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF 
    will use the changed result instead of the result that was actually returned from the operation. 
 - Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set 
   exception as if the operation had thrown the exception.
   
 - An interceptor can also set the Exception property to null to indicate that no exception should be thrown. This can 
   be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded. 
   This usually also involves setting the Result so that EF has some result value to work with as it continues.
   
##### OriginalResult and OriginalException

- After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail 
  or the Exception and OriginalException properties if execution failed with an exception.

- The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation. 
  These properties cannot be set by interceptors. 
- This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor 
  as opposed to the real exception or result that occurred when the operation was executed.
  
  ##### Registering interceptors
  
 - Once a class that implements one or more of the interception interfaces has been created it can be registered with EF 
   using the DbInterception class.
 ```
 DbInterception.Add(new NLogCommandInterceptor());
```
 - Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.
 
 ##### Example: Logging to NLog
 
 - an example that using IDbCommandInterceptor and NLog to:
    - Log a warning for any command that is executed non-asynchronously
    - Log an error for any command that throws when executed

```
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```

- Notice how this code uses the interception context to discover when a command is being executed non-asynchronously 
  and to discover when there was an error executing a command.
  

- 





  

